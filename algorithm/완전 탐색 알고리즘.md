## 브루트 포스(Brute Force)

컴퓨터 과학에서 Brute Force는 시행착오 방법론을 말한다. 또한, 암호학에서도 이 용어를 사용하기도 한다.

암호학에서는 Brute Force Attack이라는 암호를 풀기 위해 모든 값을 대입하는 방법이 있다. 즉, 모든 값을 대입하면서 수많은 시행착오를 통해 암호를 해독하여 데이터를 해킹하는데 사용한다.

예를 들어, 0부터 9 사이의 4자리 숫자의 암호를 모르는 상태에서 풀어야 한다면, 0000부터 9999까지의 경우의 수를 모두 대입하여 암호를 해독해야 한다. 이 경우 최대 10000가지의 경우의 수가 존재한다. 이렇게 모든 경우의 수를 대입하여 암호를 해독하는 방법이 Brute Force Attack이다.

## 완전 탐색 알고리즘(Brute Force Algorithm)

Brute Force Algorithm은 암호학의 Brute Force Attack과 비슷한 방법으로 무차별 대입을 나타내는 알고리즘이다. 순수 컴퓨터 성능에만 의존하여 모든 가능성을 시도하여 문제를 해결하는 것이다.

이는 Brute Force 방법이 최적의 솔루션이 아니라는 것을 의미하기도 한다.

즉, Brute Force 알고리즘은 공간 복잡도와 시간 복잡도를 고려하지 않고 문제 해결 방법을 찾아내는 것이다.

**완전 탐색 알고리즘의 사용**

1. 프로세스 속도를 높이는데 사용할 수 있는 다른 알고리즘이 없을 때
2. 문제를 해결하는 여러 솔루션이 있고 각 솔루션을 확인해야 할 때

예를 들어, 특정 문서에서 “Hello”라는 문자열을 찾아야 한다고 가정한다.

이 때, 사전과 같이 모든 단어가 정렬되어 있다면, 이진 탐색 알고리즘을 이용하여 범위를 절반씩 줄여서 찾을 수 있다. 이럴 경우 O(log n)의 시간 복잡도를 가지게 된다.

하지만, 해당 문서는 사전과 같이 정렬되어 있지 않다면, 이진 탐색 알고리즘을 사용하더라도 “Hello”라는 문자열을 찾기 위해서는 각 단어를 반복해서 비교해야 한다. 즉, 시간 복잡도 O(n)과 같게 된다.

따라서 완전 탐색 알고리즘은 문제에 더 적절한 해결 방법을 찾기 전에 시도하는 방법이다. 하지만, 데이터의 범위가 커지면 커질수록 비효율적이게 된다.

**완전 탐색 알고리즘의 한계**

위의 설명에서 유추할 수 있듯이 완전 탐색 알고리즘은 문제의 복잡도에 민감하여 비효율적인 알고리즘이 될 수 있다. 문제가 복잡할수록 시간도 오래걸리며 컴퓨터 자원을 많이 사용하게 된다.

## **완전 탐색 알고리즘의 예시**

완전 탐색 알고리즘은 한계가 명확한 알고리즘임에도 불구하고 많은 곳에서 사용한다.

**순차 검색 알고리즘 (Sequential Search)**

배열 안에 특정 값이 존재하는지 검색할 때 인덱스 0부터 마지막 인덱스까지 차례대로 검색하는 알고리즘이다.

**문자열 매칭 알고리즘(Brute-Force String Matching)**

길이가 n인 전체 문자열에서 길이가 m인 문자열 패턴이 포함하는지 등을 검색하는 알고리즘이다.

**선택 정렬 알고리즘(Selection Sort)**

전체 배열을 모든 요소와 비교하여 해당 배열이 완전히 정렬될 때 까지 교환하는 정렬 알고리즘이다.

**버블 정렬 알고리즘(Buble Sort)**

서로 인접한 두 원소를 검사하여 인접한 요소가 크기 순서대로 정렬되어 있지 않으면 서로 교환하여 정렬될 때 까지 반복하는 정렬 알고리즘이다.

**Tree 자료 구조의 완전 탐색 알고리즘**

깊이 우선 탐색(DFS)와 너비 우선 탐색(BFS)가 있다.

**동적 계획법(DP: Dynamic Programing)**

하나의 큰 문제를 여러 개의 작은 문제로 나누어 그 결과를 저장하고, 다시 큰 문제를 해결하는 알고리즘이다.