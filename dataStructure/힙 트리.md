## Heap tree란?

heap tree는 트리 구조로 구현된 자료구조이다. 일반적인 트리 구조와는 다르게, heap tree는 우선순위에 따라서 빠르게 자료를 검색할 수 있는 구조로 되어 있다.

데이터의 우선순위를 정하여 우선순위가 높은 데이터를 먼저 찾아내고, 처리하기 위해 만들어진 자료구조가 heap tree이다.

힙 트리는 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 구분할 수 있다.

## Heap tree의 구조


heap tree는 느슨한 정렬 구조로 구현되어 있다. 느슨한 정렬 구조는 부모 노드의 값은 자식 노드의 값보다 항상 크거나 항상 작게 정렬되어 있다. 하지만 자식 노드끼리의 값의 크기에 따라 좌우 위치를 정렬하지는 않기 때문에 느슨한 정렬 구조라 부른다.

## heap tree의 특징

**1. 완전 이진 트리**

heap tree는 완전 이진 트리로 구성되어 있다. 데이터의 삽입, 삭제를 효율적으로 다루기 위해 완전 이진트리로 구현한다.

**2. 중복 허용**

일반적인 이진 탐색 트리와는 다르게 중복 값 저장을 허용한다. 이는 최댓값과 최솟값을 빠르게 찾기 위한 구조이기 때문이다.

**3. 최대 힙과 최소 힙**

heap tree 자료구조는 최대 힙과 최소 힙으로 구현한다. 최대 힙은 루트 노드에 가장 큰 값이 위치하며, 자식 노드는 항상 부모 노드보다 작은 값을 가지게 되는 구조이다. 최소 힙은 최대 힙의 반대로 루트 노드에 가장 작은 값이 위치하며, 자식 노드로 내려갈 수록 큰 값을 가지게 된다.

## heap tree의 데이터 처리 방식

**데이터 검색**

heap tree의 경우 최댓값과 최소값을 빠르게 찾기 위한 구조이다.

최대 힙의 경우 최댓값을 찾는데 걸리는 시간 복잡도는 O(1)이다. 이는 최대 힙의 최댓값은 루트 노드의 값이기 루트 노드를 불러오기만 하면 된다.

반대로 최소 힙의 경우 최솟값을 찾는데 걸리는 시간 복잡도는 O(1)이다.

**데이터 삽입**

heap tree의 최대 힙에서 데이터 삽입 흐름은 다음과 같다.

1. 가장 마지막 노드에 새로운 값을 저장한다.
2. 삽입된 노드의 값과 부모 노드의 값을 비교한다.
3. 삽입한 값이 부모 값보다 더 크다면, 위치를 변경한다.
4. 더 이상 위치가 바뀌지 않을 때 까지 위 과정을 반복한다.

**데이터 삭제**

heap tree의 최대 힙에서 데이터 삭제 흐름은 다음과 같다.

1. 루트 노드의 값을 제거한다.
2. 루트 자리에 마지막 노드의 값을 삽입한다.
3. 새로 갱신된 루트 노드 값을 자식 노드들과 비교한다.
4. 만약, 루트 보다 더 큰 자식이 있다면 해당 자식과 교환 한다. (두 자식 모두 부모보다 크다면, 둘 중 더 큰 값과 바꾼다.)
5. 더 이상 큰 값이 없을 때 까지 반복한다.

## heap tree를 배열로 구현하기

heap tree는 완전 이진 트리로 구현되어 배열로 표현할 수 있다.

완전 이진 트리의 특성상 중간에 빈 값이 없기 때문에, 루트 노드로부터 높이 순서대로 배열에 모두 정렬이 가능하다.

구현과 노드의 위치를 찾기 쉽게 하기 위해 일반적으로 배열의 0번째 인덱스는 사용하지 않고, 첫 번째 인덱스부터 사용한다.

배열로 heap tree를 구현한다면, 배열의 크기에 따라 heap tree의 깊이(depth)가 얼마인지, 부모와 자식 노드의 위치까지도 쉽게 검색할 수 있다.

깊이(depth)는 배열의 길이가 1, 3, 7, 15, 31 순으로 2의 배수를 계속 더한 만큼 늘어난다.

부모와 자식 노드의 인덱스를 찾는 방법도 수식으로 계산할 수 있다.