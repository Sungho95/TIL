## Hash Table이란?

Hash table이란 해시함수(hash function)를 사용하여 변환한 해시(hash)를 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조이다.

예를 들어, 휴대폰에서 특정 번호를 단축번호로 설정하여 사용하는 것과 유사하다. 010-0000-0000 번호를 단축번호 1번으로 설정하면 1번만 누르면 해당 번호로 바로 연락이 가능하다. 이처럼 필요한 데이터의 키(key)를 해시함수를 사용하여 별도의 해시(hash)값으로 바꾸고, 해당 데이터를 함께 저장하는 구조인 것이다.

## **HashTable의 구조**

Hash Table은 키와 해시함수, 해시, 데이터로 이루어져 있다.

**키(key)**

해시 테이블의 고유한 값으로 해시 함수의 입력값이 된다. 다양한 길이의 값이 들어올 수 있으며, 해시 함수를 통해 변호나하지 않은 상태로 저장한다면, 해당 길이만큼의 저장소를 구성해야 하기 때문에 해시 함수를 통해 값을 바꾸어 저장하게 된다.

**해시 함수(hash Function)**

해시함수는 키(key)를 해시(hash)로 바꾸기 위한 함수이다. 다양한 길이를 가지고 있는 키를 일정한 길이를 갖도록 변환하여 효율적으로 메모리를 운영하기 위해 사용한다. 만약, 서로 다른 키가 같은 해시(hash)가 되는 경우를 해시 충돌이라 하며, 해시 충돌을 최대한 줄이는 것이 중요하다.

**해시(hash)**

키를 해시 함수를 통해 변환된 결과물을 뜻한다. 데이터와 매칭되어 저장되며, 변환된 값을 배열의 index와 같이 사용하게 된다.

**데이터(value)**

저장소에 최종적으로 저장되는 색인(index)과 매칭되어 저장된다.

## **HashTable의 특징**

hash table은 저장, 삭제, 검색 과정이 모두 평균적으로 O(1)의 시간복잡도를 가지고 있어 데이터를 다루는 작업이 매우 빠르다. 다만, 해시 충돌이 발생할 수 있고, 데이터가 저장되기 전에 저장공간을 미리 만들어놓아야 하기 때문에 공간 효율성이 떨어진다. 또한, 해시 함수(hash Function)의 의존도가 높다.

즉, 해시 함수가 복잡하면 복잡할수록 해시 값을 만들어내는 데 많은 시간이 소요된다.

**해시 테이블의 저장, 삭제, 검색 과정**

hash table에서 값을 저장, 삭제, 검색하기 위해서는 해시 함수에 키값을 넣어 해시 값을 구해야 한다. 이후 만들어진 해시 값과 일치하는 색인(index)을 찾아 저장하거나 삭제, 검색하는 방식이다.

해시 테이블의 저장, 삭제, 검색 작업의 시간복잡도는 O(1)이다. 해시 함수를 거쳐 해시 값을 찾아내는 데 걸리는 과정은 고려하지 않는다.

그러나 해시 충돌이 발생할 경우 저장소의 모든 색인(index) 혹은 데이터를 찾아야 하기 때문에 O(n)이 된다.

**해시 알고리즘의 종류**

**Division Method**

Number Type의 키를 저장소의 크기로 나누어 나온 나머지를 색인(index)으로 사용하는 방법이다. 저장소의 크기를 소수(Prime Number)로 정하고 2의 제곱수와 먼 값을 사용하는 것이 효과적이다.

예를 들어, Key 값이 23일 때 테이블 크기가 7이라면, index는 23 % 7인 2가 된다.

**Digit Folding**

키의 문자열을 아스키(ASCII) 코드로 바꾸고, 그 값을 합하여 저장소에서 색인(index)으로 사용하는 방법이다. 만약, 색인이 저장소의 크기를 넘어간다면 Division Method를 적용할 수 있다.

**Multiplication Method**

숫자로 된 Key 값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 계산한 값을 사용한다. index = (K*A mod 1) * m 연산을 통해 해시 값을 구한다.

**Universal Hashing**

다수의 해시함수를 만들어 특정한 장소에 넣어두고, 무작위로 해시함수를 선택하여 해시 값을 만드는 기법이다.

## 해시 충돌을 해결하는 방법

**개방 연결법(Open Addressing)**

개방 연결법은 해시 충돌이 발생하면 다른 색인에 해당 자료를 삽입하는 방식으로 크게 Linear Probing, Quadratic Probing, Double Hasing Probing 등이 있다.

Linear Probing : 중복된 색인으로부터 고정된 숫자만큼 이동하여 비어있는 저장소를 찾아 데이터를 저장하는 방법

Quadratic Probing : 중복된 색인으로부터 이동할 숫자를 제곱하여 사용하는 방식으로 첫 충돌 시 1(1^2), 이후 부터 2^2, 3^2 순으로 이동하여 빈 공간을 탐색한다.

Double Hasing Probing : 하나의 해시함수에서 충돌이 발생하면, 미리 지정한 다른 해시함수를 적용시켜 새로운 주소를 받아 사용하는 방법이다.

**분리 연결법(Seperate Chaining)**

분리 연결법은 동일한 색인의 데이터에 대해 연결 리스트(Linked List), 트리(Red-black Tree) 등의 자료구조를 활용해 데이터의 주소를 저장하는 방법이다.

분리 연결법의 경우 다른 방법에 비해 구현이 간단하며, 데이터를 쉽게 삭제할 수 있는 장점이 있다. 하지만, 중복으로 저장되는 데이터가 많아질수록 동일한 버킷에 연결되는 데이터가 많아져 검색의 효율성이 떨어진다.

**저장소 확장(Resize)**
저장소의 크기가 작은 경우, 불필요한 메모리 사용을 줄일 수 있지만, 해시 충돌이 발생할 가능성이 높아지며, 개방 연결법과 분리 연결법을 사용해도 손실이 발생한다. 이를 해결하기 위해 Java에서는 HashMap 자료구조는 key-value 데이터가 저장소의 75%이상 사용할 경우 저장소의 크기를 두 배로 늘리는 방식을 사용하고 있다. 이 방식으로 해시 충돌로 인한 성능 저하 문제를 어느 정도 해결할 수 있다.